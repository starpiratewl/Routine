library(stats)
library(survival)

## Information of data

data(package = "survival")  # List datasets in survival package
help(bladder1)              # Description of data
head(bladder1)              # Show first 6 rows
str(bladder1)               # Check type of variables
summary(bladder1)           # Statistical summary

## Get the final data with nonzero follow-up
bladder1$time <- as.numeric(bladder1$stop - bladder1$start)
summary(bladder1$time)
bladder1 <- subset(bladder1,status<=1 & time>0)


## Step1 Create Kaplan-Meier curve and estimate median survial/event time 
## The "log-log" confidence interval is preferred.
## Create overval Kaplan-Meier curve
km.as.one <- survfit(Surv(time, status) ~ 1, data = bladder1, conf.type = "log-log")

## Create Kaplan-Meier curve stratified by treatment
km.by.trt <- survfit(Surv(time, status) ~ treatment, data = bladder1, conf.type = "log-log")

## Show simple statistics of Kaplan-Meier curve
km.as.one
km.by.trt

## See survival estimates at given time (lots of outputs)
summary(km.as.one)
summary(km.by.trt)

## Plot Kaplan-Meier curve without any specification
plot(km.as.one)
plot(km.by.trt)

## Plot Kaplan-Meier curve Without confidence interval and mark of event
plot(km.as.one, conf = F, mark.time = F)
plot(km.by.trt, conf = F, mark.time = F)


## step2 Create a simple cox regression and estimate HR:
model1 <-coxph(Surv(time, status) ~ treatment + number +size, data=bladder1)

## Model output
summary(model1)                    # Output summary information
confint(model1)                    # Output 95% CI for the coefficients
exp(coef(model1))                  # Output HR (exponentiated coefficients)
exp(confint(model1))               # 95% CI for exponentiated coefficients
predict(model1, type="risk")       # predicted values
residuals(model1, type="deviance") # residuals


## Step3 Check for violation of proportional hazard (constant HR over time)
model1.zph <- cox.zph(model1)
model1.zph                    
## Note: p value of treatmentthiotepa <0.05
## GLOBAL p value is more important than p values of treatmentthiotepa 
## Only GLOBAL p value <0.05 is neccesary for solution of violation
## Following steps are just for providing examples

## Displays a graph of the scaled Schoenfeld residuals, along with a smooth curve.
plot(model1.zph)

## Step4 Solution of violating of proportional hazard

## Solution 1 Stratify: create a stratified cox model,namely "contitional cox model "
model2 <-coxph(Surv(start, stop, status) ~ number +size + strata (treatment), data=bladder1)
summary(model2) 
model2.zph <- cox.zph(model2)
model2.zph

## Solution 1 Create a simple time-dependent model without time-dependent variable
model3 <-coxph(Surv(start, stop, status) ~ number + size + treatment, data=bladder1)
summary(model3) 

## Create a time-dependent model with time-dependent variable

bladder1$thiotepa <- as.numeric (bladder1$treatment=="thiotepa")
model4 <-coxph(Surv(start, stop, status) ~ number +size + treatment + thiotepa:time, data=bladder1)
## Note: "thiotepa:time" but not "thiotepa*time"

summary(model4) 

## Step5 Performs stepwise model selection by AIC

## Default direction is "backward"
model5 <-step(model4)
summary(model5)


## rms::survplot() function
## Load rms package
library(rms)

## Plot Kaplan-Meier curve without any specification
fit1 <- npsurv(Surv(time, status) ~ 1, data = bladder1)
fit2 <- npsurv(Surv(time, status) ~ treatment, data = bladder1)
survplot(fit1)
survplot(fit2)

## Plot Kaplan-Meier curve Without confidence interval
survplot(fit1, conf = "none")
survplot(fit2, conf = "none")

## More options for Kaplan-Meier curve
survplot(fit2, 
         xlab = "Time, month",                  # add x-axis label
         ylab = "Survival probability, %",      # add y-axis label
         ## xlim=c(0,60),                       # add x-axis limits
         ## ylim=c(-0.1,1),                     # add y-axis limits
         ## conf.int=.95,                       # show 95% CI,
         conf='none',                           # change type of CI
         label.curves = list(keys = "lines"),   # legend instead of direct label
         levels.only  = TRUE,                   # show only levels, no label
         col=c('red','green','blue'),           # change legend color
         ## fun = function(x) {1 - x},          # Cumulative probability plot
         ## loglog   = TRUE,                    # log(-log Survival) plot
         ## logt     = TRUE,                    # log time
         time.inc = 5,                          # time increment
         ## dots     = TRUE,                    # dot grid
         n.risk   = TRUE,                       # show number at risk
         y.n.risk = 0.01,                       # Change position of number at risk
         cex.n.risk = 0.6                       # change character size for number at risk
         )
         


####################################################################################################################
## survival plot test
####################################################################################################################
A=data.frame()
#输入变量
x=c(2, -2.5, 3.5, 4, 4, -5, 6, -6, 7, -7, 8, -9, 10.5, 12.5, 19, 2.5, 5, 7, -8.5, 9, -10, 11, -11, 12, 13, -14, 15, -16, 17, -18, 19, -20, 21, 24, 32)

#若survt小于0(代表数据删失)，则变量censor赋值为1，否则，赋值为0
for (i in 1:length(x))
{
  A[i,1]=x[i]
  if(A[i,1]<0)
    A[i,2]=1
  else
    A[i,2]=0
}
#分为high-wbc和low-wbc两组
A[,3] <- c(rep("high",15),rep("low",20))
A[,1] <- abs(x)
#变量命名
names(A) <- c("survt","censor","wbc")

A
##   survt censor  wbc
##1    2.0      0 high
##2    2.5      1 high
##3    3.5      0 high
##4    4.0      0 high
##5    4.0      0 high
##6    5.0      1 high
##7    6.0      0 high
##8    6.0      1 high
##9    7.0      0 high
##10   7.0      1 high
##11   8.0      0 high
##12   9.0      1 high
##13  10.5      0 high
##14  12.5      0 high
##15  19.0      0 high
##16   2.5      0  low
##17   5.0      0  low
##18   7.0      0  low
##19   8.5      1  low
##20   9.0      0  low
##21  10.0      1  low
##22  11.0      0  low
##23  11.0      1  low
##24  12.0      0  low
##25  13.0      0  low
##26  14.0      1  low
##27  15.0      0  low
##28  16.0      1  low
##29  17.0      0  low
##30  18.0      1  low
##31  19.0      0  low
##32  20.0      1  low
##33  21.0      0  low
##34  24.0      0  low
##35  32.0      0  low



# 建立生存对象
library(survival)
Surv(A$survt,A$censor==1)

# 估计KM生存曲线(Kaplan–Meier estimator乘积极限法)
y <- Surv(A$survt,A$censor==1)
kmfit1 <- survfit(y~1)
summary(kmfit1)
plot(kmfit1)

# 根据wbc分组估计KM生存曲线
kmfit2 <- survfit(y~A$wbc)
plot(kmfit2, lty = c('solid', 'dashed'), col=c('black','blue'), xlab='survival time in days',ylab='survival probabilities')
legend('topright', c('wbc high','wbc low'), lty=c('solid','dashed'), col=c('black','blue'))



# 检验显著性,rho=0为log-rank法或Mantel Haenszel法，rho=1为Wilcoxon法
survdiff(Surv(survt,censor)~wbc, data=A,rho = 0)
survdiff(Surv(survt,censor)~wbc, data=A,rho = 1)

#设置不同函数的不同参数，选择不同的检验方法
survreg(Surv(survt,censor)~wbc, data=A,dist="weibull")
survreg(Surv(survt,censor)~wbc, data=A,dist="logistic")
survreg(Surv(survt,censor)~wbc, data=A,dist="lognormal")


#-logS(p)对生存时间t的散点图
kmfit3=kmfit2
kmfit3$surv=-log(kmfit3$surv)
b1=data.frame(kmfit3$time[1:12],kmfit3$surv[1:12])
b2=data.frame(kmfit3$time[13:31],kmfit3$surv[13:31])
plot(b1,type="b",col="black",main="估计生存函数的负数对数")
lines(b2,type="b",col="blue")
legend('bottomright', c('wbc high','wbc low'), lty=c('solid','dashed'), col=c('black','blue'))

##此资料不服从指数分布，近似服从Weibull分布，故宜选用对数秩法或Wilcoxon法检验的结果，两条生存曲线分布有显著性差异（p<0.05）。结果显示：两条生存曲线Wilcoxon检验的结果为p=0.025<0.05，两条生存曲线分布有显著差异，无WBC倍增的白血病患者的生存时间显著长于有WBC倍增的白血病患者。

##生存函数图，横轴为生存时间t（治疗后生存的月份），纵轴为生存概率。High-WBC（有WBC倍增）在第20个月终止，low-WBC（无WBC倍增）在第32个月终止。其第一组的生存率下降速度显著快于第二组，说明无WBC倍增的患者比有WBC倍增患者的生存时间长。

##上述-logS(p)对生存时间t的散点图，呈非直线趋势，说明生存时间不呈指数分布。


#log（-logS(t)）对log(t)的散点图
kmfit4=kmfit3
kmfit4$surv=log(kmfit4$surv)
C1=data.frame(kmfit4$time[1:12],kmfit4$surv[1:12])
C2=data.frame(kmfit4$time[13:31],kmfit4$surv[13:31])
plot(C1,type="b",col="black",main="估计生存函数的负数对数的对数")
lines(C2,type="b",col="blue")
legend('bottomright', c('wbc high','wbc low'), lty=c('solid','dashed'), col=c('black','blue'))

##上述为log（-logS(t)）对log(t)的散点图，两条线分别近似直线，说明生存时间近似呈Weibull分布。



# 由word文件里的公式--（n.risk差值）/（n.risk*time差值），画出wbc分别为high和low的死亡风险函数图
summary(kmfit2)
B =data.frame(kmfit2$time[1:12],kmfit2$n.risk[1:12])
B$rr= 0
for (i in 2:12)
{
  B[i,3]=(B[i-1,2]-B[i,2])/(B[i-1,2]*(B[i,1]-B[i-1,1]))
}

plot(B$rr~B$kmfit2.time.1.12.,xlab = "t",ylab = "死亡率",col="black",type="l",main="死亡风险函数")
legend('topright', c('wbc high','wbc low'), lty=c('solid','dashed'),
       col=c('black','blue'))

C =data.frame(kmfit2$time[13:31],kmfit2$n.risk[13:31])
C$rr= 0
for (i in 2:19)
{
  C[i,3]=(C[i-1,2]-C[i,2])/(C[i-1,2]*(C[i,1]-C[i-1,1]))
}

lines(C$rr~C$kmfit2.time.13.31.,col="blue",type="l")

##给出生存时间T对应的死亡风险函数。黑色曲线表现的是high-WBC组对应的风险率，蓝色曲线表现的是low-WBC对应的风险率，从图中看出：体内WBC倍增的病人死亡的风险率更高。



##2. 用图形方法检验PH假设 （与1.中对数图相似）
plot(kmfit2,fun='cloglog',xlab='time in days using logarithmic scale',ylab='log-log survival', main='log-log curves by wbc')
##不平行，不符合PH假设

##3. 构建COX PH回归模型
#cox模型
y <- Surv(A$survt,A$censor == 1)
coxmodel <- coxph(y~wbc,data=A)
summary(coxmodel)

# 此例中只有wbc一个变量，不涉及到两模型选择问题。假如有多个变量，可以选择y~x1+x2+x3,y~x1+x2+x3+x3*x2+x3*x1这两个模型
mod1 <- coxph(y ~ wbc,data=A)
#再用anova函数比较两个模型
#anova(mod1,mod2)
#step(mod2)
# 简洁模型更好
# 风险预测
predict(mod1,type='risk')


## 此例中只有wbc一个变量，不涉及到两模型选择问题。假如有多个变量，可以选择y~x1+x2+x3,y~x1+x2+x3+x3*x2+x3*x1这两个模型
#构建一个stratified Cox model.
# 当PH假设在clinic不成立，控制这个变量
#mod3 <- coxph(y ~ prison + dose + strata(clinic),data=addicts)
#summary(mod3)


##对PH假设进行统计检验
mod1 <- coxph(y ~ wbc,data=A)
cox.zph(mod1,transform=rank)
# P值小显示PH假设不符合
# 显示系数变化图
plot(cox.zph(mod1,transform=rank),se=F)


##得到COX调整后生存曲线
mod1 <- coxph(y ~ wbc,data=A)
pattern1 <- data.frame(wbc = 'low')
summary(survfit(mod1,newdata=pattern1))
plot(survfit(mod1,newdata=pattern1),conf.int=F)

mod2 <- coxph(y ~ strata(wbc),data=A)
pattern2 <- data.frame(wbc = 'high')


##构建参数模型
modpar1 <- survreg(Surv(A$survt)~wbc,data=A,dist='exponential')
summary(modpar1)






####################################################################################################################
## calculation of AUC
####################################################################################################################

install.packages(c("clinfun","CPE","risksetROC", "timeROC", "survivalROC","survC1","survIDINRI"))

library(survival)

set.seed(666)
age <- rnorm(400, 50, 10)
bp  <- rnorm(400,120, 15)
d.time <- rexp(400)
cens   <- runif(400,.5,2)
death  <- d.time <= cens
d.time <- pmin(d.time, cens)

fit <- coxph(Surv(d.time,death) ~ age + bp)
summary(fit) 
# Concordance = 0.502  (se = 0.019 ) 

# Compute the concordance between a right-censored 
# survival time and a single continuous covariate
survConcordance(Surv(d.time,death) ~ predict(fit))
# Concordance = 0.502101  (se = 0.01883032 )
# Concordance = concordant/(concordant+discordant)

library(Hmisc)
# Computes the c index and the corresponding generalization of 
# Somers' Dxy rank correlation for a censored response variable.
rcorrcens(Surv(d.time,death) ~ predict(fit))
# C index: 1 - 0.498 = 0.502 
# C index = (1+aDxy)/2 = (1+0.004)/2 = 0.502

library(risksetROC)
tmax <- max(d.time)
# Create and plot AUC based on incident/dynamic definition of Heagerty
AUC <- risksetAUC(Stime=d.time, status=death,
                  marker=age + bp, method="Cox", tmax=tmax)
AUC$Cindex
# 0.5020833

library(clinfun)
# Calculate Gonen & Heller concordance probability estimate (CPE) for 
# for the Cox proportional hazards model.
coxphCPE(fit)
# CPE= 0.50884256, se.CPE = 0.01678487 

library(CPE)
# Calculate Gonen & Heller concordance probability estimate (CPE) 
# for the Cox proportional hazards model.
phcpe(fit, CPE.SE=TRUE,out.ties=TRUE)
# CPE= 0.5088426, se.CPE = 0.01678487 


library(survivalROC)
# Time-dependent ROC curve estimation from censored survival data
AUC2 <- survivalROC(Stime=d.time, status=death, marker = eta, predict.time =  265, method="KM")

AUC2$AUC
# 0.6124465 

plot(AUC2$FP, AUC2$TP, type="l", xlim=c(0,1), ylim=c(0,1), xlab=paste( "FP", "\n", "AUC = ",round(AUC2$AUC,3)), ylab="TP",main="AUC2, Method = KM \n Year = 1")

abline(0,1)

library(timeROC)
# Time-dependent ROC curve estimation
ROC<-timeROC(T=d.time,
             delta=death,
             marker=eta,
             other_markers=as.matrix(bp),
             cause=1,
             weighting="marginal",
             times=quantile(d.time,probs=seq(0.2,0.8,0.1)),
             ROC = TRUE,
             iid = TRUE)
ROC
confint(ROC)
