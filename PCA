setwd("D:\\importantbk\\working\\lab_working\\biochip_overall\\work_for_article\\PCAs\\Abt_Water")


exp_tab <- read.csv(file = "Abt_Water.txt", sep = "\t", stringsAsFactors = F, header = T)


exp_tab_groups <- exp_tab[,c(2,3,6,7)]

sd=scale(exp_tab_groups)

write.table(sd, file = "test_sd.txt", sep = "\t", quote = F, col.names = T, row.names = F)


sd_tab <- read.csv(file = "test_sd.txt", sep = "\t", stringsAsFactors =F)

chip.dat.pca<-princomp(exp_tab_groups, cor = F)










dcor <- cor(sd_tab)
deig=eigen(dcor)
sum(deig$value[1:2])/4




colour<-c(rep(2,2),rep(3,2))

library(rgl)

tab_loadings = loadings(chip.dat.pca)

Comp.1 = tab_loadings[,1]
Comp.2 = tab_loadings[,2]

plot(Comp.1,Comp.2 ,col = colour, xlim = c(0.48,0.52), ylim = c(-0.5,1.0))
plot(Comp.1,Comp.2 ,col = colour)





##pr<-princomp(~var1+var2+var3+var4,data=a,cor=TRUE,scores=TRUE) 

pr<-princomp(~Abt_1_NS+Abt_2_NS+Water_1_NS+Water_2_NS,data=exp_tab_groups,cor=F,scores=TRUE) 


tab_loadings = loadings(pr)

Comp.1 = tab_loadings[,1]
Comp.2 = tab_loadings[,2]
plot(Comp.1,Comp.2 ,col = colour)











test_tab <- t(exp_tab_groups)

test_pac <- princomp(test_tab, cor = F)

######################################################
## youtube test
######################################################



power <- c(60,35,74,30,80,90,50)
space <- c(58,40,68,40,70,95,50)
design <- c(25,75,50,60,50,80,45)


dat <- cbind(power, space, design)
row.names(dat) <- c("a","b","c","d","e","f","g")


pca1 <- princomp(dat, cor = F)


tab_loadings = loadings(pca1)

Comp.1 = tab_loadings[,1]
Comp.2 = tab_loadings[,2]

plot(Comp.1,Comp.2 ,col = colour)








######################################################
## ClustVis test
######################################################



Unit variance scaling is applied to rows; SVD with imputation is used to calculate principal components. X and Y axis show principal component 1 and principal component 2 that explain 41.9% and 31.7% of the total variance, respectively. N = 4 data points.





######################################################
## test from paper
######################################################

setwd("C:\\Users\\WL\\Desktop\\PCA_test")

## Importing your matrix data into R (in this demonstration, a matrix available from GEO is used)
masterdata<-read.table(file="GSE31291_Summarized_Matrix.txt", sep="\t", header=T)
masterdata1 <- masterdata[, 1:40*3+1]
rownames(masterdata1)<-masterdata[,1]
colnames(masterdata1)<-colnames(masterdata)[ 1:40*3-1]
masterdata2<- as.matrix(masterdata1)

(masterdata[1:10,] )



## ANOVA
ANOVA_negatives <- NA   #  In fact, many of the genes were negative.
# Here, this demonstration will represent Figure 1C;
# hence, for comparison, it will use ANOVA negative genes as well. 
# However, in practice, such genes should be removed to reduce the noise effects.

## Preparing the training_data 
num_sample 	<- 	ncol(masterdata2)
num_gene 	<- 	nrow(masterdata2)
num_repeat 	<- 	4  # number of each repeat

training<-array(NA, dim=c(num_gene, num_sample/num_repeat))

for(gene in 1:num_gene){
	for(group in 1:(num_sample/num_repeat)){
	training[gene,group]<- mean(masterdata[gene, 1:num_repeat+(group-1)*num_repeat], na.rm=T)
}}

rownames(training)<-masterdata2[,1]
colnames(training)<- 0:9

## Centering
center <- apply(training, 1, mean, na.rm=T)   	# setting the mean data as the reference
# center <- training[,1]			# alternative: 0h as the reference
X <- sweep(training, 1, center)
X <- t(X)    # transpose of X 
X_c <- sweep(masterdata2, 1, center) # complete data
X_c <- t(X_c)    

##  Removing NAs (and ANOVA negatives)
X[is.na(X)]<-0
	X[ ,ANOVA_negatives] <- 0 # removing noisy items by replacing the data with zero
X_c[is.na(X_c)]<-0
X_c[ ,ANOVA_negatives]<-0 

## SVD
#  singular value decomposition of X  
res_svd <- svd(X)
Left <- res_svd$u		# the left singular vectors
Right <- res_svd$v		# the right singular vectors
sqL <- diag(res_svd$d)		# diagonal matrix of the singular values

#  calculation of the principal components 
PC_gene  	<-	t(X) %*% Left		#/ Right %*% sqL
PC_groups	<-	X %*% Right		#/ Left %*% sqL
PC_all_samples <- 	X_c %*% Right 		# applying the axes to other data sets
proportion <- res_svd$d^2/sum(res_svd$d^2)*100	# proportion of characteristic roots

# scaling of the principal components 
sPC_gene <- PC_gene /sqrt( nrow(X) )
sPC_groups <- PC_groups / sqrt( ncol(X) )
sPC_all_samples <- PC_all_samples / sqrt( ncol(X))   

### Presentation of sPC1 and sPC2
#  barplot(proportion)
groups<- sort(rep(0:9,4))
plot(sPC_gene[,1], sPC_gene[,2]   )  # , pch=NA, xlim=c(-.25,.25), ylim=c(-.25,.25))
text(sPC_all_samples[,1], sPC_all_samples[,2], labels=groups, col="green2")

## Exporting the resulted PCs
write.table(sPC_all_samples, file="PC_samples.txt", sep="\t")
write.table(sPC_groups, file="PC_groups.txt", sep="\t")
write.table(sPC_gene, file="PC_gene.txt", sep="\t")

## Tomokazu Konishi, 5 Oct 2011, konishi@akita-pu.ac.jp



######################################################
## test of PCA with CV filtered data
######################################################

setwd("C:\\Users\\WL\\Desktop\\PCA_test")


all_tab <- read.csv(file = "Abt_VS_Water_CV.txt", header = T, stringsAsFactor = F, sep = "\t")
all_tab_no <- all_tab[!is.na(all_tab$GeneSymbol),]

## CV of Actb is 0.001776247
## the most CV of Actb and gapdh is 0.005, so there will be different approach to filter
all_filter1 <- all_tab_no[all_tab_no$CV > 0.001776247, ]
all_filter2 <- all_tab_no[all_tab_no$CV > 0.005, ]


all_filter1 <- all_filter1[,c(1,2,3,6,7)]
all_filter2 <- all_filter2[,c(1,2,3,6,7)]

write.table(all_filter1, file = "all_filter1.txt", sep = "\t", row.names = F, col.names = T, quote = F)
write.table(all_filter2, file = "all_filter2.txt", sep = "\t", row.names = F, col.names = T, quote = F)













