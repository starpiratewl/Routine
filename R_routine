##############################################
## order ,rank , sort
##############################################
haha <- c(1,9,7,2,4,6,5,3,8)
sort(haha)
##[1] 1 2 3 4 5 6 7 8 9
order(haha)
##[1] 1 4 8 5 7 6 3 9 2
rank(haha)
##[1] 1 9 7 2 4 6 5 3 8
haha[order(haha)]
##[1] 1 2 3 4 5 6 7 8 9
haha[order(-haha)]
##[1] 9 8 7 6 5 4 3 2 1
order(haha)[sort(haha)>5&sort(haha)<9]
##[1] 6 3 9





##############################################
## get the reverse seq of a vector
##############################################
DNA <- "ATTAGCGTACGTAGCTCATGC"
DNA1 <- unlist(strsplit(DNA1,""))
DNA1
##[1] "A" "T" "T" "A" "G" "C" "G" "T" "A" "C" "G" "T" "A" "G" "C" "T" "C" "A" "T" "G" "C"
rev(DNA1)
##[1] "C" "G" "T" "A" "C" "T" "C" "G" "A" "T" "G" "C" "A" "T" "G" "C" "G" "A" "T" "T" "A"


##############################################
## basic operation with vectors
##############################################

## truncate the vector
m <- c(1,2,3,NA,NA,4,5)
m[-which(is.na(m))]
m[-c(4,5)]

## subtract b from a
a<-10:100
b<-sample(a,40,replace=FALSE)

a[-match(b,a)]

setdiff(a, b)

a[!a%in%b]


## appoint names to vectors
years <- c(1960,1964,1976,1994)
names(years) <- c("Kennedy","Johnson","Carter","Clinton")
years
##Kennedy Johnson  Carter Clinton 
##   1960    1964    1976    1994 







##############################################
## subset
##############################################
newdata <- subset(leadership, age >= 35 | age < 24,
select=c(q1, q2, q3, q4))
newdata <- subset(leadership, gender=="M" & age > 25,
select=gender:q4)


##############################################
## add prefix or postfix to a vector
##############################################
a <- c(789000,267980,256780,89,123,890)

sprintf("%06d.%s", a, ifelse(nchar(a) == 6, "sz", "sh"))
[1] "789000.sz" "267980.sz" "256780.sz" "000089.sh" "000123.sh" "000890.sh"






##############################################
## merge
##############################################
id1 <- c(2, 3, 4, 5, 7)
heights <- c(62, 65, 71, 71, 67)
df1 <- data.frame(id = id1, heights)

id2 <- c(1, 2, 6:10)
weights <- c(147, 113, 168, 135, 142, 159, 160)
df2 <- data.frame(id = id2, weights)

df1
##  id heights
##1  2      62
##2  3      65
##3  4      71
##4  5      71
##5  7      67

df2
##  id weights
##1  1     147
##2  2     113
##3  6     168
##4  7     135
##5  8     142
##6  9     159
##7 10     160


merge(df1, df2, all = FALSE)
##  id heights weights
##1  2      62     113
##2  7      67     135
merge(df2, df1, all = FALSE)
##  id weights heights
##1  2     113      62
##2  7     135      67

intersect(df1$id, df2$id)
##[1] 2 7

##执行merge函数时，函数自动会找到两个数据框df1和df2共有的列，即id那一列（即相当于by= "id"），当参数all= FALSE时，会将两个数据框中该列数值相等的那些行输出来，类似于对这两个数据框的id这一列求交集（intersection)。此例中是id为2或7这两行。此外，还可以发现df1和df2的输入顺序不会影响最终结果，仅仅会影响输出结果中heights和weights这两列的顺序。incomparables参数:指定by中哪些单元不进行合并.


merge(df1, df2, by = "id", all = TRUE)
##   id heights weights
##1   1      NA     147
##2   2      62     113
##3   3      65      NA
##4   4      71      NA
##5   5      71      NA
##6   6      NA     168
##7   7      67     135
##8   8      NA     142
##9   9      NA     159
##10 10      NA     160


sort(union(df1$id, df2$id))
##[1]  1  2  3  4  5  6  7  8  9 10

merge(df1, df2, by = "id", all.x = TRUE)
##  id heights weights
##1  2      62     113
##2  3      65      NA
##3  4      71      NA
##4  5      71      NA
##5  7      67     135

merge(df1, df2, by = "id", all.y = TRUE)
##  id heights weights
##1  1      NA     147
##2  2      62     113
##3  6      NA     168
##4  7      67     135
##5  8      NA     142
##6  9      NA     159
##7 10      NA     160


df1$sex <- c("f", "m", "f", "f", "m")
df2$sex <- c("f", "f", "m", "m", "f", "f", "f")

merge(df1, df2)
##  id sex heights weights
##1  2   f      62     113
##2  7   m      67     135

merge(df1, df2, by = c("id", "sex"))
##   id sex heights weights
## 1  2   f      62     113
## 2  7   m      67     135


merge(df1, df2, by = "id")
##   id heights sex.x weights sex.y
## 1  2      62     f     113     f
## 2  7      67     m     135     m


##############################################
##  R sql
##############################################
library(sqldf)
newdf <- sqldf("select * from mtcars where carb=1 order by mpg",row.names=TRUE)
newdf
##                mpg cyl  disp  hp drat    wt  qsec vs am gear carb
##Valiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
##Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
##Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
##Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
##Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
##Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
##Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1


sqldf("select avg(mpg) as avg_mpg, avg(disp) as avg_disp, gear from mtcars where cyl in (4, 6) group by gear")
##   avg_mpg avg_disp gear
##1 20.33333 201.0333    3
##2 24.53333 123.0167    4
##3 25.36667 120.1333    5











##############################################
## file manipulation in R
##############################################
path <- "/XX/";              #设定需修改文件集合所在的主目录（修改这里）
setwd(path)                  # 设置为当前目录

old.file.names <- dir()      # 返回当前目录下所有文件名集合，类型为向量

## 设置新的命名规则
new.file.names <- sapply(old.file.names,function(file){

  # 新的命名规则，下例为所有文件统一加后缀，本部分可根据具体情况修改（修改这里）
  file <- paste0(file,".mkv")

  return (file)
})

# 执行批量命名操作
file.rename(old.file.names,new.file.names)




##############################################
## How to sort a dataframe by column(s)?
##############################################

> mtcars[order(mtcars$disp),]
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4

> mtcars[order(mtcars$gear,mtcars$disp),]
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4






############################################################
## insert one or more vectors into another vector
############################################################
m <- c(1,2,NA,6,101,102,NA,106)
x <- c(3,4,5)
y <- c(103,104,105)

## key method: vector[seq(n)]
ins <- function(a, to.insert=list(), pos=c()) {
  c(a[seq(pos[1])], 
    to.insert[[1]], 
    a[seq(pos[1]+1, pos[2])], 
    to.insert[[2]], 
    a[seq(pos[2], length(a))]
    )
}

ins(m,list(x,y),which(is.na(m)))
## [1]   1   2  NA   3   4   5   6 101 102  NA 103 104 105  NA 106




## key method: vector[seq(n)], index+1 and index-1 to omit the NA value
ins2 <- function(a, to.insert=list(), pos=c()) {
  c(a[seq(pos[1]-1)], 
    to.insert[[1]], 
    a[seq(pos[1]+1, pos[2]-1)], 
    to.insert[[2]], 
    a[seq(pos[2]+1, length(a))]
    )
}

ins2(m,list(x,y),which(is.na(m)))
## [1]   1   2   3   4   5   6 101 102 103 104 105 106




## here we want insert tow FALSE into a vector of TRUE in 5 and 10 position

## key method: order() function, this is a nice but sneaky approach
probs <- rep(TRUE, 15)
ind <- c(5, 10)
val <- c( probs, rep(FALSE,length(ind)) )
id  <- c( seq_along(probs), ind+0.5 )
val[order(id)]

## key method: append() function, notice that with append() function we not only can insert one element but also can insert another vector
probes <- rep(TRUE, 15)
probes <- append(probes, FALSE, after=5)
probes <- append(probes, FALSE, after=11) ## notice here,we use after = 11 not after = 10 because we have inserted one and the seq number should add one more, that is alos why in the next solution, we use after=(ind[i+1]+i) in the for loop.

## this one is more applicable
probes <- rep(TRUE, 15)
ind <- c(5, 10)
for(i in 0:(length(ind)-1)) 
    probes <- append(probes, FALSE, after=(ind[i+1]+i))
    
    


## another function, key method: the basic attributes of vector itself. m[x:y]
insert <- function(v,e,pos){
   return(c(v[1:(pos-1)],e,v[(pos):length(v)]))
} 



##########################################################################################################
## dealing with the "mapping" problem, this problem is similar to the vlookup function in R
## we realise this in R with the help of merge() function
## this is a long standing problem in my coding life, everytime will try different approach, but 
## the merge() function is the best, so I need to formulate it and become a fixed method
##########################################################################################################

company1 <- c("A","B","C","D","E","F")
sales <- c(100,200,300,400,500,600)

company2 <- c("A","B","C","D","E","G")
managers <- c("Tom","Jim","Mike","John","Sam","Luke")

sales_tab <- cbind(company1, sales)
managers_tab <- cbind(company2, managers)

merge(sales_tab,managers_tab, by.x = "company1", by.y = "company2", all = T)
  company1 sales managers
1        A   100      Tom
2        B   200      Jim
3        C   300     Mike
4        D   400     John
5        E   500      Sam
6        F   600     <NA>
7        G  <NA>     Luke





